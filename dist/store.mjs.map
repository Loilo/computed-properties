{"version":3,"file":"store.mjs","sources":["../src/helpers.ts","../src/reaction.ts","../src/observable-array.ts","../src/observable-object.ts","../src/store.ts"],"sourcesContent":["import { PlainObject } from './data-structures'\n\n/**\n * Checks if value is a plain object\n */\nexport function isPlainObject (value: any): value is PlainObject {\n  return typeof value === 'object' && value !== null && value.prototype == null\n}\n\n/**\n * Checks if value is an observable object or array\n */\nexport function isObservable (value) {\n  return !!((Array.isArray(value) || (typeof value === 'object' && value !== null && !value.prototype)) && value.$destroy)\n}\n\n/**\n * Use this instead of Object.assign() for compatibility\n */\nexport function extend (...objects: PlainObject[]) {\n  if (objects.length === 0) throw new TypeError('Cannot convert undefined or null to object')\n\n  // @ts-ignore: Empty `objects` is not possible\n  if ('assign' in Object) return Object.assign(...objects)\n\n  if (objects.length === 1) return objects[0]\n\n  for (let key in objects[1]) {\n    objects[0][key] = objects[1][key]\n  }\n\n  return extend(objects[0], ...objects.slice(2))\n}\n","import ObservableArray from './observable-array'\nimport ObservableObject from './observable-object'\nimport { isObservable, isPlainObject, extend } from './helpers'\n\nexport function reactify (callback, value) {\n  if (isObservable(value)) {\n    return value\n  } else if (Array.isArray(value)) {\n    const copy = value.slice(0)\n\n    for (let i = 0; i < copy.length; i++) {\n      copy[i] = reactify(callback, copy[i])\n    }\n\n    const observable = ObservableArray(callback, ...copy)\n\n    return observable\n  } else if (isPlainObject(value)) {\n    const copy = extend({}, value)\n\n    for (const key in copy) {\n      copy[key] = reactify(callback, copy[key])\n    }\n\n    const observable = ObservableObject(callback, copy)\n\n    return observable\n  } else {\n    return value\n  }\n}\n\nexport function raw (value) {\n  return isObservable(value) ? value.$raw() : value\n}\n\nexport function unreactify (value) {\n  return isObservable(value) ? value.$destroy() : value\n}\n","import { reactify, unreactify } from './reaction'\n\n/**\n * Minimal implementation of an observable array\n */\nexport default function ObservableArray (callback, ...source) {\n  let silent = true\n  const items = []\n  const notify = () => {\n    if (!silent) callback()\n  }\n  const reactifyItem = item => reactify(callback, item)\n\n  // Execute the original method\n  const x = (method, ...args) => Array.prototype[method].call(items, ...args)\n\n  Object.defineProperty(items, 'push', {\n    value: function push (...newItems) {\n      const result = x('push', ...newItems.map(reactifyItem))\n      if (newItems.length) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'pop', {\n    value: function pop () {\n      const affected = items.length\n      const result = x('pop')\n      if (affected) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'shift', {\n    value: function shift () {\n      const affected = items.length\n      const result = x('shift')\n      if (affected) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'unshift', {\n    value: function unshift (...newItems) {\n      const result = x('unshift', ...newItems.map(reactifyItem))\n      if (newItems.length) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'splice', {\n    value: function splice (start, deleteCount, ...newItems) {\n      const result = x('splice', start, deleteCount, ...newItems.map(reactifyItem))\n      if (result.length || newItems.length) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'sort', {\n    value: function sort (sorter) {\n      const result = x('sort', sorter)\n      notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'reverse', {\n    value: function reverse () {\n      const result = x('reverse')\n      notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, '$raw', {\n    value () {\n      return items.slice(0)\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, '$set', {\n    value: function $set (index, value) {\n      items[index] = reactifyItem(value)\n      notify()\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, '$destroy', {\n    value: function $destroy () {\n      silent = true\n      return items.map(unreactify)\n    },\n    enumerable: false\n  })\n\n  // Initially add items\n  items.push(...source)\n\n  // Cancel silence\n  silent = false\n\n  return items\n}\n","import { reactify, raw } from './reaction'\nimport { extend } from './helpers'\n\n/**\n * Minimal implementation of an observable object\n */\nexport default function ObservableObject (callback, source) {\n  const iface = Object.create(null)\n\n  let silent = true\n\n  const props = []\n\n  const notify = () => {\n    if (!silent) callback()\n  }\n\n  function init () {\n    for (const key of Object.keys(source)) {\n      defineProperty(key, source[key])\n    }\n  }\n\n  function rawObject () {\n    return Object.getOwnPropertyNames(iface)\n      .filter(key => key[0] !== '$')\n      .reduce((carry, key) =>\n        extend(Object.create(null), carry, { [key]: raw(iface[key]) })\n      , Object.create(null))\n  }\n\n  function defineProperty (prop, value) {\n    if (props.indexOf(prop) !== -1) {\n      throw new Error(`Property ${prop} is already defined`)\n    }\n\n    let currentValue = value\n    Object.defineProperty(iface, prop, {\n      get () {\n        return currentValue\n      },\n      set (newValue) {\n        const affected = newValue !== currentValue\n        currentValue = reactify(callback, newValue)\n        if (affected) notify()\n      },\n      enumerable: true,\n      configurable: true\n    })\n\n    props.push(prop)\n\n    notify()\n  }\n\n  Object.defineProperty(iface, '$set', {\n    value (prop, value) {\n      defineProperty(prop, value)\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(iface, '$raw', {\n    value () {\n      return rawObject()\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(iface, '$destroy', {\n    value () {\n      silent = true\n      return rawObject()\n    },\n    enumerable: false\n  })\n\n  init()\n\n  silent = false\n\n  return iface\n}\n","import { reactify, raw } from './reaction'\nimport { extend } from './helpers'\nimport { FlatValue, FlatObject } from './data-structures'\n\nexport type ReactiveValue = string | number | boolean | ReactiveObject | ReactiveArray | Function\n\nexport interface ReactiveInstance {\n  $raw (): any\n  $set (...args: any[]): void\n  $destroy (): any\n}\n\nexport interface ReactiveObject extends ReactiveInstance {\n  [prop: string]: ReactiveValue\n\n  $raw (): Array<ReactiveValue>\n  $set (prop: string, value: FlatValue): void\n  $destroy (): FlatObject\n}\n\nexport interface ReactiveArray extends Array<ReactiveValue>, ReactiveInstance {\n  $raw (): Array<ReactiveValue>\n  $set (index: number, value: FlatValue): void\n  $destroy (): Array<FlatValue>\n}\n\nexport type StaticProp = FlatValue\nexport type ReactiveProp = () => any\n\nexport interface StoreData {\n  [prop: string]: StaticProp | ReactiveProp\n}\n\ntype Store<U = any> = {\n  [T in keyof U]: U[T]\n} & {\n  $raw (): U\n  $watch<T extends keyof U> (prop: T, callback: (now?: U[T], previous?: U[T]) => void): () => void\n}\n\nfunction Store<T> (data: { [U in keyof T]: T[U] | ((this: T) => T[U]) }, { verbose = false } = {}): Store<T> {\n  const watchers = Object.create(null)\n\n  // Intermediate tracking data\n  let isCurrentlyTrackingPropAccess = false\n  let currentlyTrackedProp = null\n  let trackedAccessCache = Object.create(null)\n\n  // Per-prop dependency cache\n  const propDependencyCache = Object.create(null)\n\n  // Value cache for computed properties\n  const computedPropCache = {}\n  const outdatedComputedPropCache = {}\n\n  // The returned object\n  const reactive = Object.create(null)\n\n  // All (static and computed) properties defined in the store\n  const allProps = Object.keys(data)\n  const computedProps = []\n\n  /**\n   * Sets up the Store\n   */\n  function init () {\n    // Assign all props\n    for (const prop of allProps) {\n      propDependencyCache[prop] = Object.create(null)\n\n      // Computed\n      if (typeof data[prop] === 'function') {\n        assignComputedProp(prop)\n        computedProps.push(prop)\n\n      // Data\n      } else {\n        assignStaticProp(prop)\n      }\n    }\n\n    /**\n     * Gets the raw values of the Store\n     *\n     * @param {Boolean} includeComputed If cached values of computed properties should be included\n     */\n    function rawObject (includeComputed) {\n      return Object.getOwnPropertyNames(reactive)\n        .filter(key => key[0] !== '$' && (includeComputed || computedProps.indexOf(key) === -1))\n        .reduce((carry, key) =>\n          extend(Object.create(null), carry, { [key]: raw(reactive[key]) })\n        , Object.create(null))\n    }\n\n    // Define the $raw method\n    Object.defineProperty(reactive, '$raw', {\n      value (includeComputed = true) {\n        return rawObject(includeComputed)\n      },\n      enumerable: false\n    })\n\n    // Define the $watch method\n    Object.defineProperty(reactive, '$watch', {\n      value (prop, listener) {\n        if (!(prop in watchers)) {\n          watchers[prop] = []\n\n          // tslint:disable-next-line\n          reactive[prop]\n        }\n\n        watchers[prop].push(listener)\n\n        return () => {\n          watchers[prop].splice(watchers[prop].indexOf(listener), 1)\n\n          if (!watchers[prop].length) {\n            delete watchers[prop]\n          }\n        }\n      },\n      enumerable: false\n    })\n\n    return reactive\n  }\n\n  /**\n   * Invalidate the cache for a certain property and all its dependencies.\n   *\n   * @param {String} prop The property to invalidate\n   */\n  function invalidateCache (prop) {\n    if (verbose) console.log('  invalidate cache of property', prop)\n\n    if (computedPropCache.hasOwnProperty(prop)) {\n      // Write invalidated value to outdated cache for access by watchers\n      outdatedComputedPropCache[prop] = computedPropCache[prop]\n      delete computedPropCache[prop]\n    }\n\n    // Force re-evaluation if watcher is present\n    if (watchers[prop]) {\n      // tslint:disable-next-line\n      reactive[prop]\n    }\n\n    // Recursively invalidate cache of dependencies\n    for (const dependant of Object.keys(propDependencyCache[prop])) invalidateCache(dependant)\n  }\n\n  /**\n   * Assign a non-reactive property\n   *\n   * @param {String} prop The property to assign\n   */\n  function assignStaticProp (prop) {\n    let currentValue = reactify(() => invalidateCache(prop), data[prop])\n\n    Object.defineProperty(reactive, prop, {\n      get () {\n        if (verbose) console.log('Accessed property', prop, '=', currentValue)\n\n        if (isCurrentlyTrackingPropAccess) {\n          if (verbose) console.log('  through tracking of computed property', currentlyTrackedProp)\n\n          trackedAccessCache[currentlyTrackedProp][prop] = true\n        }\n        return currentValue\n      },\n\n      set (value) {\n        if (value === currentValue) return\n\n        const oldValue = currentValue\n        currentValue = reactify(() => invalidateCache(prop), value)\n\n        // Invalidate dependant properties' cache\n        if (verbose) console.log('Set value of property', prop, '=', currentValue)\n        if (verbose) console.log('  dependencies to notify:', Object.keys(propDependencyCache[prop]))\n\n        for (const dependency of Object.keys(propDependencyCache[prop])) {\n          invalidateCache(dependency)\n        }\n\n        // Notify watchers\n        if (watchers[prop]) watchers[prop].forEach(watcher => watcher(currentValue, oldValue))\n      }\n    })\n  }\n\n  /**\n   * Re-evaluates a computed property\n   *\n   * @param {String} prop The property to re-evaluate\n   */\n  function reevaluateComputedProp (prop) {\n    // Check current tracking state\n    const wasAlreadyTracking = isCurrentlyTrackingPropAccess\n    const previouslyTrackedProp = currentlyTrackedProp\n\n    // Set new tracking state\n    isCurrentlyTrackingPropAccess = true\n    currentlyTrackedProp = prop\n\n    // Track access\n    trackedAccessCache[prop] = Object.create(null)\n    const value = (data[prop] as ReactiveProp).call(reactive, reactive)\n    const dependencies = Object.keys(trackedAccessCache[prop] || Object.create(null))\n    delete trackedAccessCache[prop]\n\n    // Revert tracking state\n    if (!wasAlreadyTracking) {\n      isCurrentlyTrackingPropAccess = false\n    } else {\n      currentlyTrackedProp = previouslyTrackedProp\n    }\n\n    return { dependencies, value }\n  }\n\n  /**\n   * Assign a computed property\n   *\n   * @param {String} prop The computed property to assign\n   */\n  function assignComputedProp (prop) {\n    let computedPropDependencies = []\n    Object.defineProperty(reactive, prop, {\n      get () {\n        if (verbose) console.log('Accessed computed property', prop)\n\n        // Mark property as accessed if tracking\n        if (isCurrentlyTrackingPropAccess) {\n          if (verbose) console.log('  through tracking of computed property', currentlyTrackedProp)\n          trackedAccessCache[currentlyTrackedProp][prop] = true\n        }\n\n        // Return cached value if present\n        if (computedPropCache.hasOwnProperty(prop)) {\n          if (verbose) console.log('  got it from cache')\n          return computedPropCache[prop]\n        }\n\n        // Check if there's an old value stored\n        const hasOutdatedValue = outdatedComputedPropCache.hasOwnProperty(prop)\n        if (verbose) {\n          console.log(hasOutdatedValue\n            ? '  it had already been changed'\n            : '  it has never been changed before')\n        }\n\n        // Re-evaluate computed property\n        const result = reevaluateComputedProp(prop)\n\n        const newDependencies = result.dependencies\n        const oldDependencies = computedPropDependencies\n\n        // Remove no longer needed dependencies\n        for (const obsoleteDependency of oldDependencies) {\n          delete propDependencyCache[obsoleteDependency][prop]\n        }\n\n        // Add computed property's new dependencies\n        for (const newDependency of newDependencies) {\n          propDependencyCache[newDependency][prop] = true\n        }\n\n        computedPropDependencies = result.dependencies\n\n        if (verbose) console.log('  re-evaluated the computed property')\n        if (verbose) console.log('    dependencies:', computedPropDependencies)\n        if (verbose) console.log('    new value:', result.value)\n\n        // Cache new value\n        computedPropCache[prop] = result.value\n\n        // Trigger watcher\n        if (hasOutdatedValue && outdatedComputedPropCache[prop] !== result.value && watchers[prop]) {\n          watchers[prop].forEach(watcher => watcher(result.value, outdatedComputedPropCache[prop]))\n        }\n\n        // Purge outdated cache\n        if (hasOutdatedValue) {\n          delete outdatedComputedPropCache[prop]\n        }\n\n        return result.value\n      }\n    })\n  }\n\n  return init()\n}\n\nexport default Store\n"],"names":["isObservable","value","Array","isArray","prototype","$destroy","extend","objects","length","TypeError","Object","assign","let","key","slice","reactify","callback","const","copy","i","silent","items","notify","reactifyItem","item","x","method","call","args","defineProperty","result","newItems","map","enumerable","affected","start","deleteCount","sorter","index","unreactify","push","source","isPlainObject","iface","create","props","rawObject","getOwnPropertyNames","filter","reduce","carry","raw","prop","indexOf","Error","currentValue","get","set","newValue","configurable","keys","init","ObservableObject","$raw","data","ref","watchers","isCurrentlyTrackingPropAccess","currentlyTrackedProp","trackedAccessCache","propDependencyCache","computedPropCache","outdatedComputedPropCache","reactive","allProps","computedProps","invalidateCache","verbose","console","log","hasOwnProperty","assignStaticProp","oldValue","forEach","watcher","assignComputedProp","computedPropDependencies","hasOutdatedValue","wasAlreadyTracking","previouslyTrackedProp","dependencies","reevaluateComputedProp","newDependencies","includeComputed","listener","splice"],"mappings":"SAYgBA,EAAcC,GAC5B,SAAWC,MAAMC,QAAQF,KAA4B,iBAAVA,GAAgC,OAAVA,GAAmBA,EAAMG,aAAeH,EAAMI,UAMjH,SAAgBC,2DACd,GAAuB,IAAnBC,EAAQC,OAAc,MAAM,IAAIC,UAAU,8CAG9C,GAAI,WAAYC,OAAQ,OAAOA,OAAOC,aAAOD,OAAGH,GAEhD,GAAuB,IAAnBA,EAAQC,OAAc,OAAOD,EAAQ,GAEzC,IAAKK,IAAIC,KAAON,EAAQ,GACtBA,EAAQ,GAAGM,GAAON,EAAQ,GAAGM,GAG/B,OAAOP,gBAAOC,EAAQ,WAAOA,EAAQO,MAAM,cC3B7BC,EAAUC,EAAUf,GAClC,GAAID,EAAaC,GACf,OAAOA,EACF,GAAIC,MAAMC,QAAQF,GAAQ,CAG/B,IAFAgB,IAAMC,EAAOjB,EAAMa,MAAM,GAEhBK,EAAI,EAAGA,EAAID,EAAKV,OAAQW,IAC/BD,EAAKC,GAAKJ,EAASC,EAAUE,EAAKC,IAKpC,gBCXqCH,iEACvCJ,IAAIQ,GAAS,EACPC,EAAQ,GACRC,aACCF,GAAQJ,KAETO,WAAeC,UAAQT,EAASC,EAAUQ,IAG1CC,WAAKC,4EAAoBxB,MAAME,UAAUsB,IAAQC,cAAKN,UAAUO,KAgGtE,OA9FAlB,OAAOmB,eAAeR,EAAO,OAAQ,CACnCpB,MAAO,kEACLgB,IAAMa,EAASL,gBAAE,eAAWM,EAASC,IAAIT,KAEzC,OADIQ,EAASvB,QAAQc,IACdQ,GAETG,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,MAAO,CAClCpB,MAAO,WACLgB,IAAMiB,EAAWb,EAAMb,OACjBsB,EAASL,EAAE,OAEjB,OADIS,GAAUZ,IACPQ,GAETG,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,QAAS,CACpCpB,MAAO,WACLgB,IAAMiB,EAAWb,EAAMb,OACjBsB,EAASL,EAAE,SAEjB,OADIS,GAAUZ,IACPQ,GAETG,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,UAAW,CACtCpB,MAAO,kEACLgB,IAAMa,EAASL,gBAAE,kBAAcM,EAASC,IAAIT,KAE5C,OADIQ,EAASvB,QAAQc,IACdQ,GAETG,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,SAAU,CACrCpB,MAAO,SAAiBkC,EAAOC,iEAC7BnB,IAAMa,EAASL,gBAAE,SAAUU,EAAOC,UAAgBL,EAASC,IAAIT,KAE/D,OADIO,EAAOtB,QAAUuB,EAASvB,SAAQc,IAC/BQ,GAETG,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,OAAQ,CACnCpB,MAAO,SAAeoC,GACpBpB,IAAMa,EAASL,EAAE,OAAQY,GAEzB,OADAf,IACOQ,GAETG,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,UAAW,CACtCpB,MAAO,WACLgB,IAAMa,EAASL,EAAE,WAEjB,OADAH,IACOQ,GAETG,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,OAAQ,CACnCpB,iBACE,OAAOoB,EAAMP,MAAM,IAErBmB,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,OAAQ,CACnCpB,MAAO,SAAeqC,EAAOrC,GAC3BoB,EAAMiB,GAASf,EAAatB,GAC5BqB,KAEFW,YAAY,IAGdvB,OAAOmB,eAAeR,EAAO,WAAY,CACvCpB,MAAO,WAEL,OADAmB,GAAS,EACFC,EAAMW,IAAIO,IAEnBN,YAAY,IAIdZ,EAAMmB,WAAKnB,EAAGoB,GAGdrB,GAAS,EAEFC,iBDhG8BL,UAAaE,IAG3C,YDZsBjB,GAC7B,MAAwB,iBAAVA,GAAgC,OAAVA,GAAqC,MAAnBA,EAAMG,UCWjDsC,CAAczC,GAAQ,CAC/BgB,IAAMC,EAAOZ,EAAO,GAAIL,GAExB,IAAKgB,IAAMJ,KAAOK,EAChBA,EAAKL,GAAOE,EAASC,EAAUE,EAAKL,IAKtC,gBEpBsCG,EAAUyB,GAClDxB,IAAM0B,EAAQjC,OAAOkC,OAAO,MAExBxB,GAAS,EAEPyB,EAAQ,GAERvB,aACCF,GAAQJ,KASf,SAAS8B,IACP,OAAOpC,OAAOqC,oBAAoBJ,GAC/BK,gBAAOnC,SAAkB,MAAXA,EAAI,KAClBoC,gBAAQC,EAAOrC,gBACdP,EAAOI,OAAOkC,OAAO,MAAOM,MAAO,IAAGrC,GAAMsC,EAAIR,EAAM9B,SACtDH,OAAOkC,OAAO,OAGpB,SAASf,EAAgBuB,EAAMnD,GAC7B,IAA6B,IAAzB4C,EAAMQ,QAAQD,GAChB,MAAM,IAAIE,kBAAkBF,yBAG9BxC,IAAI2C,EAAetD,EACnBS,OAAOmB,eAAec,EAAOS,EAAM,CACjCI,eACE,OAAOD,GAETE,aAAKC,GACHzC,IAAMiB,EAAWwB,IAAaH,EAC9BA,EAAexC,EAASC,EAAU0C,GAC9BxB,GAAUZ,KAEhBW,YAAY,EACZ0B,cAAc,IAGhBd,EAAML,KAAKY,GAEX9B,IA6BF,OA1BAZ,OAAOmB,eAAec,EAAO,OAAQ,CACnC1C,eAAOmD,EAAMnD,GACX4B,EAAeuB,EAAMnD,IAEvBgC,YAAY,IAGdvB,OAAOmB,eAAec,EAAO,OAAQ,CACnC1C,iBACE,OAAO6C,KAETb,YAAY,IAGdvB,OAAOmB,eAAec,EAAO,WAAY,CACvC1C,iBAEE,OADAmB,GAAS,EACF0B,KAETb,YAAY,IAzDd,WACE,IAAK,UAAavB,OAAOkD,KAAKnB,mBAAS,CAAlCxB,IAAMJ,OACTgB,EAAehB,EAAK4B,EAAO5B,KA0D/BgD,GAEAzC,GAAS,EAEFuB,EFzDcmB,CAAiB9C,EAAUE,GAI9C,OAAOjB,WAIKkD,EAAKlD,GACnB,OAAOD,EAAaC,GAASA,EAAM8D,OAAS9D,WAG9BsC,EAAYtC,GAC1B,OAAOD,EAAaC,GAASA,EAAMI,WAAaJ,iBGGlD,SAAmB+D,EAAsDC,kBAAsB,oCAAV,GACnFhD,IAAMiD,EAAWxD,OAAOkC,OAAO,MAG3BuB,GAAgC,EAChCC,EAAuB,KACvBC,EAAqB3D,OAAOkC,OAAO,MAGjC0B,EAAsB5D,OAAOkC,OAAO,MAGpC2B,EAAoB,GACpBC,EAA4B,GAG5BC,EAAW/D,OAAOkC,OAAO,MAGzB8B,EAAWhE,OAAOkD,KAAKI,GACvBW,EAAgB,GAyEtB,SAASC,EAAiBxB,GACpByB,GAASC,QAAQC,IAAI,iCAAkC3B,GAEvDmB,EAAkBS,eAAe5B,KAEnCoB,EAA0BpB,GAAQmB,EAAkBnB,UAC7CmB,EAAkBnB,IAU3B,IAAK,UAAmB1C,OAAOkD,KAAKU,EAAoBlB,oBAAQwB,QAQlE,SAASK,EAAkB7B,GACzBxC,IAAI2C,EAAexC,oBAAe6D,EAAgBxB,IAAOY,EAAKZ,IAE9D1C,OAAOmB,eAAe4C,EAAUrB,EAAM,CACpCI,eAQE,OAPIqB,GAASC,QAAQC,IAAI,oBAAqB3B,EAAM,IAAKG,GAErDY,IACEU,GAASC,QAAQC,IAAI,0CAA2CX,GAEpEC,EAAmBD,GAAsBhB,IAAQ,GAE5CG,GAGTE,aAAKxD,GACH,GAAIA,IAAUsD,EAAd,CAEAtC,IAAMiE,EAAW3B,EACjBA,EAAexC,oBAAe6D,EAAgBxB,IAAOnD,GAGjD4E,GAASC,QAAQC,IAAI,wBAAyB3B,EAAM,IAAKG,GACzDsB,GAASC,QAAQC,IAAI,4BAA6BrE,OAAOkD,KAAKU,EAAoBlB,KAEtF,IAAK,UAAoB1C,OAAOkD,KAAKU,EAAoBlB,oBACvDwB,QAIEV,EAASd,IAAOc,EAASd,GAAM+B,iBAAQC,UAAWA,EAAQ7B,EAAc2B,SAwClF,SAASG,EAAoBjC,GAC3BxC,IAAI0E,EAA2B,GAC/B5E,OAAOmB,eAAe4C,EAAUrB,EAAM,CACpCI,eAUE,GATIqB,GAASC,QAAQC,IAAI,6BAA8B3B,GAGnDe,IACEU,GAASC,QAAQC,IAAI,0CAA2CX,GACpEC,EAAmBD,GAAsBhB,IAAQ,GAI/CmB,EAAkBS,eAAe5B,GAEnC,OADIyB,GAASC,QAAQC,IAAI,uBAClBR,EAAkBnB,GAI3BnC,IAAMsE,EAAmBf,EAA0BQ,eAAe5B,GAC9DyB,GACFC,QAAQC,IAAIQ,EACR,gCACA,sCAUN,IANAtE,IAAMa,EAzDZ,SAAiCsB,GAE/BnC,IAAMuE,EAAqBrB,EACrBsB,EAAwBrB,EAG9BD,GAAgC,EAChCC,EAAuBhB,EAGvBiB,EAAmBjB,GAAQ1C,OAAOkC,OAAO,MACzC3B,IAAMhB,EAAS+D,EAAKZ,GAAuBzB,KAAK8C,EAAUA,GACpDiB,EAAehF,OAAOkD,KAAKS,EAAmBjB,IAAS1C,OAAOkC,OAAO,OAU3E,cATOyB,EAAmBjB,GAGrBoC,EAGHpB,EAAuBqB,EAFvBtB,GAAgC,EAK3B,cAAEuB,QAAczF,GAmCJ0F,CAAuBvC,GAEhCwC,EAAkB9D,EAAO4D,mBACPJ,yBAIfhB,QAAwClB,GAIjD,IAAK,UAAuBwC,kBAC1BtB,QAAmClB,IAAQ,EAsB7C,OAnBAkC,EAA2BxD,EAAO4D,aAE9Bb,GAASC,QAAQC,IAAI,wCACrBF,GAASC,QAAQC,IAAI,oBAAqBO,GAC1CT,GAASC,QAAQC,IAAI,iBAAkBjD,EAAO7B,OAGlDsE,EAAkBnB,GAAQtB,EAAO7B,MAG7BsF,GAAoBf,EAA0BpB,KAAUtB,EAAO7B,OAASiE,EAASd,IACnFc,EAASd,GAAM+B,iBAAQC,UAAWA,EAAQtD,EAAO7B,MAAOuE,EAA0BpB,MAIhFmC,UACKf,EAA0BpB,GAG5BtB,EAAO7B,SAKpB,OApOA,WAEE,IAAK,UAAcyE,kBAAU,CAAxBzD,IAAMmC,OACTkB,EAAoBlB,GAAQ1C,OAAOkC,OAAO,MAGhB,mBAAfoB,EAAKZ,IACdiC,EAAmBjC,GACnBuB,EAAcnC,KAAKY,IAInB6B,EAAiB7B,GAgDrB,OA9BA1C,OAAOmB,eAAe4C,EAAU,OAAQ,CACtCxE,eAAO4F,GACL,uBADuB,GAV3B,SAAoBA,GAClB,OAAOnF,OAAOqC,oBAAoB0B,GAC/BzB,gBAAOnC,SAAkB,MAAXA,EAAI,KAAegF,IAAmD,IAAhClB,EAActB,QAAQxC,MAC1EoC,gBAAQC,EAAOrC,gBACdP,EAAOI,OAAOkC,OAAO,MAAOM,MAAO,IAAGrC,GAAMsC,EAAIsB,EAAS5D,SACzDH,OAAOkC,OAAO,OAMTE,CAAU+C,IAEnB5D,YAAY,IAIdvB,OAAOmB,eAAe4C,EAAU,SAAU,CACxCxE,eAAOmD,EAAM0C,GAUX,OATM1C,KAAQc,IACZA,EAASd,GAAQ,IAMnBc,EAASd,GAAMZ,KAAKsD,cAGlB5B,EAASd,GAAM2C,OAAO7B,EAASd,GAAMC,QAAQyC,GAAW,GAEnD5B,EAASd,GAAM5C,eACX0D,EAASd,KAItBnB,YAAY,IAGPwC,EAwKFZ"}