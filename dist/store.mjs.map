{"version":3,"file":"store.mjs","sources":["../src/helpers.ts","../src/reaction.ts","../src/observable-array.ts","../src/observable-object.ts","../src/store.ts"],"sourcesContent":["import { PlainObject } from './data-structures'\n\n/**\n * Checks if value is a plain object\n */\nexport function isPlainObject (value: any): value is PlainObject {\n  return typeof value === 'object' && value !== null && value.prototype == null\n}\n\n/**\n * Checks if value is an observable object or array\n */\nexport function isObservable (value) {\n  return !!((Array.isArray(value) || (typeof value === 'object' && value !== null && !value.prototype)) && value.$destroy)\n}\n\n/**\n * Use this instead of Object.assign() for compatibility\n */\nexport function extend (...objects: PlainObject[]) {\n  if (objects.length === 0) throw new TypeError('Cannot convert undefined or null to object')\n\n  // @ts-ignore: Empty `objects` is not possible\n  if ('assign' in Object) return Object.assign(...objects)\n\n  if (objects.length === 1) return objects[0]\n\n  for (let key in objects[1]) {\n    objects[0][key] = objects[1][key]\n  }\n\n  return extend(objects[0], ...objects.slice(2))\n}\n","import ObservableArray from './observable-array'\nimport ObservableObject from './observable-object'\nimport { isObservable, isPlainObject, extend } from './helpers'\n\nexport function reactify (callback, value) {\n  if (isObservable(value)) {\n    return value\n  } else if (Array.isArray(value)) {\n    const copy = value.slice(0)\n\n    for (let i = 0; i < copy.length; i++) {\n      copy[i] = reactify(callback, copy[i])\n    }\n\n    const observable = ObservableArray(callback, ...copy)\n\n    return observable\n  } else if (isPlainObject(value)) {\n    const copy = extend({}, value)\n\n    for (const key in copy) {\n      copy[key] = reactify(callback, copy[key])\n    }\n\n    const observable = ObservableObject(callback, copy)\n\n    return observable\n  } else {\n    return value\n  }\n}\n\nexport function raw (value) {\n  return isObservable(value) ? value.$raw() : value\n}\n\nexport function unreactify (value) {\n  return isObservable(value) ? value.$destroy() : value\n}\n","import { reactify, unreactify } from './reaction'\n\n/**\n * Minimal implementation of an observable array\n */\nexport default function ObservableArray (callback, ...source) {\n  let silent = true\n  const items = []\n  const notify = () => {\n    if (!silent) callback()\n  }\n  const reactifyItem = item => reactify(callback, item)\n\n  // Execute the original method\n  const x = (method, ...args) => Array.prototype[method].call(items, ...args)\n\n  Object.defineProperty(items, 'push', {\n    value: function push (...newItems) {\n      const result = x('push', ...newItems.map(reactifyItem))\n      if (newItems.length) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'pop', {\n    value: function pop () {\n      const affected = items.length\n      const result = x('pop')\n      if (affected) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'shift', {\n    value: function shift () {\n      const affected = items.length\n      const result = x('shift')\n      if (affected) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'unshift', {\n    value: function unshift (...newItems) {\n      const result = x('unshift', ...newItems.map(reactifyItem))\n      if (newItems.length) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'splice', {\n    value: function splice (start, deleteCount, ...newItems) {\n      const result = x('splice', start, deleteCount, ...newItems.map(reactifyItem))\n      if (result.length || newItems.length) notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'sort', {\n    value: function sort (sorter) {\n      const result = x('sort', sorter)\n      notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, 'reverse', {\n    value: function reverse () {\n      const result = x('reverse')\n      notify()\n      return result\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, '$raw', {\n    value () {\n      return items.slice(0)\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, '$set', {\n    value: function $set (index, value) {\n      items[index] = reactifyItem(value)\n      notify()\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(items, '$destroy', {\n    value: function $destroy () {\n      silent = true\n      return items.map(unreactify)\n    },\n    enumerable: false\n  })\n\n  // Initially add items\n  items.push(...source)\n\n  // Cancel silence\n  silent = false\n\n  return items\n}\n","import { reactify, raw } from './reaction'\nimport { extend } from './helpers'\n\n/**\n * Minimal implementation of an observable object\n */\nexport default function ObservableObject (callback, source) {\n  const iface = Object.create(null)\n\n  let silent = true\n\n  const props = []\n\n  const notify = () => {\n    if (!silent) callback()\n  }\n\n  function init () {\n    for (const key of Object.keys(source)) {\n      defineProperty(key, source[key])\n    }\n  }\n\n  function rawObject () {\n    return Object.getOwnPropertyNames(iface)\n      .filter(key => key[0] !== '$')\n      .reduce((carry, key) =>\n        extend(Object.create(null), carry, { [key]: raw(iface[key]) })\n      , Object.create(null))\n  }\n\n  function defineProperty (prop, value) {\n    if (props.indexOf(prop) !== -1) {\n      throw new Error(`Property ${prop} is already defined`)\n    }\n\n    let currentValue = value\n    Object.defineProperty(iface, prop, {\n      get () {\n        return currentValue\n      },\n      set (newValue) {\n        const affected = newValue !== currentValue\n        currentValue = reactify(callback, newValue)\n        if (affected) notify()\n      },\n      enumerable: true,\n      configurable: true\n    })\n\n    props.push(prop)\n\n    notify()\n  }\n\n  Object.defineProperty(iface, '$set', {\n    value (prop, value) {\n      defineProperty(prop, value)\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(iface, '$raw', {\n    value () {\n      return rawObject()\n    },\n    enumerable: false\n  })\n\n  Object.defineProperty(iface, '$destroy', {\n    value () {\n      silent = true\n      return rawObject()\n    },\n    enumerable: false\n  })\n\n  init()\n\n  silent = false\n\n  return iface\n}\n","import { reactify, raw } from './reaction'\nimport { extend } from './helpers'\nimport { FlatValue, FlatObject } from './data-structures'\n\n// Using the global Reflect actually is a hack to prevent TypeScript from\n// removing raw property access\nconst accessProp = Reflect\n  ? Reflect.get\n  : ((object: any, prop: string) => object[prop])\n\nexport type ReactiveValue = string | number | boolean | ReactiveObject | ReactiveArray | Function\n\nexport interface ReactiveInstance {\n  $raw (): any\n  $set (...args: any[]): void\n  $destroy (): any\n}\n\nexport interface ReactiveObject extends ReactiveInstance {\n  [prop: string]: ReactiveValue\n\n  $raw (): Array<ReactiveValue>\n  $set (prop: string, value: FlatValue): void\n  $destroy (): FlatObject\n}\n\nexport interface ReactiveArray extends Array<ReactiveValue>, ReactiveInstance {\n  $raw (): Array<ReactiveValue>\n  $set (index: number, value: FlatValue): void\n  $destroy (): Array<FlatValue>\n}\n\nexport type StaticProp = FlatValue\nexport type ReactiveProp = () => any\n\nexport interface StoreData {\n  [prop: string]: StaticProp | ReactiveProp\n}\n\ntype Store<U = any> = {\n  [T in keyof U]: U[T]\n} & {\n  $raw (): U\n  $watch<T extends keyof U> (prop: T, callback: (now?: U[T], previous?: U[T]) => void): () => void\n}\n\nfunction Store<T> (data: { [U in keyof T]: T[U] | ((this: T) => T[U]) }, { verbose = false } = {}): Store<T> {\n  const watchers = Object.create(null)\n\n  // Intermediate tracking data\n  let isCurrentlyTrackingPropAccess = false\n  let currentlyTrackedProp = null\n  let trackedAccessCache = Object.create(null)\n\n  // Per-prop dependency cache\n  const propDependencyCache = Object.create(null)\n\n  // Value cache for computed properties\n  const computedPropCache = {}\n  const outdatedComputedPropCache = {}\n\n  // The returned object\n  const reactive = Object.create(null)\n\n  // All (static and computed) properties defined in the store\n  const allProps = Object.keys(data)\n  const computedProps = []\n\n  /**\n   * Sets up the Store\n   */\n  function init () {\n    // Assign all props\n    for (const prop of allProps) {\n      propDependencyCache[prop] = Object.create(null)\n\n      // Computed\n      if (typeof data[prop] === 'function') {\n        assignComputedProp(prop)\n        computedProps.push(prop)\n\n      // Data\n      } else {\n        assignStaticProp(prop)\n      }\n    }\n\n    /**\n     * Gets the raw values of the Store\n     *\n     * @param {Boolean} includeComputed If cached values of computed properties should be included\n     */\n    function rawObject (includeComputed) {\n      return Object.getOwnPropertyNames(reactive)\n        .filter(key => key[0] !== '$' && (includeComputed || computedProps.indexOf(key) === -1))\n        .reduce((carry, key) =>\n          extend(Object.create(null), carry, { [key]: raw(reactive[key]) })\n        , Object.create(null))\n    }\n\n    // Define the $raw method\n    Object.defineProperty(reactive, '$raw', {\n      value (includeComputed = true) {\n        return rawObject(includeComputed)\n      },\n      enumerable: false\n    })\n\n    // Define the $watch method\n    Object.defineProperty(reactive, '$watch', {\n      value (prop, listener) {\n        if (!(prop in watchers)) {\n          watchers[prop] = []\n          accessProp(reactive, prop)\n        }\n\n        watchers[prop].push(listener)\n\n        return () => {\n          watchers[prop].splice(watchers[prop].indexOf(listener), 1)\n\n          if (!watchers[prop].length) {\n            delete watchers[prop]\n          }\n        }\n      },\n      enumerable: false\n    })\n\n    return reactive\n  }\n\n  /**\n   * Invalidate the cache for a certain property and all its dependencies.\n   *\n   * @param {String} prop The property to invalidate\n   */\n  function invalidateCache (prop) {\n    if (verbose) console.log('  invalidate cache of property', prop)\n\n    if (computedPropCache.hasOwnProperty(prop)) {\n      // Write invalidated value to outdated cache for access by watchers\n      outdatedComputedPropCache[prop] = computedPropCache[prop]\n      delete computedPropCache[prop]\n    }\n\n    // Force re-evaluation if watcher is present\n    if (watchers[prop]) {\n      accessProp(reactive, prop)\n    }\n\n    // Recursively invalidate cache of dependencies\n    for (const dependant of Object.keys(propDependencyCache[prop])) invalidateCache(dependant)\n  }\n\n  /**\n   * Assign a non-reactive property\n   *\n   * @param {String} prop The property to assign\n   */\n  function assignStaticProp (prop) {\n    if (verbose) console.log('Define static property', prop)\n\n    let currentValue = reactify(() => invalidateCache(prop), data[prop])\n\n    Object.defineProperty(reactive, prop, {\n      get () {\n        if (verbose) console.log('Accessed property', prop, '=', currentValue)\n\n        if (isCurrentlyTrackingPropAccess) {\n          if (verbose) console.log('  through tracking of computed property', currentlyTrackedProp)\n\n          trackedAccessCache[currentlyTrackedProp][prop] = true\n        }\n        return currentValue\n      },\n\n      set (value) {\n        if (value === currentValue) return\n\n        const oldValue = currentValue\n        currentValue = reactify(() => invalidateCache(prop), value)\n\n        // Invalidate dependant properties' cache\n        if (verbose) console.log('Set value of property', prop, '=', currentValue)\n        if (verbose) console.log('  dependencies to notify:', Object.keys(propDependencyCache[prop]))\n\n        for (const dependency of Object.keys(propDependencyCache[prop])) {\n          invalidateCache(dependency)\n        }\n\n        // Notify watchers\n        if (watchers[prop]) watchers[prop].forEach(watcher => watcher(currentValue, oldValue))\n      }\n    })\n  }\n\n  /**\n   * Re-evaluates a computed property\n   *\n   * @param {String} prop The property to re-evaluate\n   */\n  function reevaluateComputedProp (prop) {\n    // Check current tracking state\n    const wasAlreadyTracking = isCurrentlyTrackingPropAccess\n    const previouslyTrackedProp = currentlyTrackedProp\n\n    // Set new tracking state\n    isCurrentlyTrackingPropAccess = true\n    currentlyTrackedProp = prop\n\n    // Track access\n    trackedAccessCache[prop] = Object.create(null)\n    const value = (data[prop] as ReactiveProp).call(reactive, reactive)\n    const dependencies = Object.keys(trackedAccessCache[prop] || Object.create(null))\n    delete trackedAccessCache[prop]\n\n    // Revert tracking state\n    if (!wasAlreadyTracking) {\n      isCurrentlyTrackingPropAccess = false\n    } else {\n      currentlyTrackedProp = previouslyTrackedProp\n    }\n\n    return { dependencies, value }\n  }\n\n  /**\n   * Assign a computed property\n   *\n   * @param {String} prop The computed property to assign\n   */\n  function assignComputedProp (prop) {\n    if (verbose) console.log('Define computed property', prop)\n\n    let computedPropDependencies = []\n    Object.defineProperty(reactive, prop, {\n      get () {\n        if (verbose) console.log('Accessed computed property', prop)\n\n        // Mark property as accessed if tracking\n        if (isCurrentlyTrackingPropAccess) {\n          if (verbose) console.log('  through tracking of computed property', currentlyTrackedProp)\n          trackedAccessCache[currentlyTrackedProp][prop] = true\n        }\n\n        // Return cached value if present\n        if (computedPropCache.hasOwnProperty(prop)) {\n          if (verbose) console.log('  got it from cache')\n          return computedPropCache[prop]\n        }\n\n        // Check if there's an old value stored\n        const hasOutdatedValue = outdatedComputedPropCache.hasOwnProperty(prop)\n        if (verbose) {\n          console.log(hasOutdatedValue\n            ? '  it had already been changed'\n            : '  it has never been changed before')\n        }\n\n        // Re-evaluate computed property\n        const result = reevaluateComputedProp(prop)\n\n        const newDependencies = result.dependencies\n        const oldDependencies = computedPropDependencies\n\n        // Remove no longer needed dependencies\n        for (const obsoleteDependency of oldDependencies) {\n          delete propDependencyCache[obsoleteDependency][prop]\n        }\n\n        // Add computed property's new dependencies\n        for (const newDependency of newDependencies) {\n          propDependencyCache[newDependency][prop] = true\n        }\n\n        computedPropDependencies = result.dependencies\n\n        if (verbose) console.log('  re-evaluated the computed property')\n        if (verbose) console.log('    dependencies:', computedPropDependencies)\n        if (verbose) console.log('    new value:', result.value)\n\n        // Cache new value\n        computedPropCache[prop] = result.value\n\n        // Trigger watcher\n        if (hasOutdatedValue && outdatedComputedPropCache[prop] !== result.value && watchers[prop]) {\n          watchers[prop].forEach(watcher => watcher(result.value, outdatedComputedPropCache[prop]))\n        }\n\n        // Purge outdated cache\n        if (hasOutdatedValue) {\n          delete outdatedComputedPropCache[prop]\n        }\n\n        return result.value\n      }\n    })\n  }\n\n  return init()\n}\n\nexport default Store\n"],"names":["isObservable","value","Array","isArray","prototype","$destroy","extend","objects","length","TypeError","Object","assign","let","key","slice","reactify","callback","copy","i","silent","items","notify","reactifyItem","item","x","method","call","args","defineProperty","result","newItems","map","enumerable","affected","start","deleteCount","sorter","index","unreactify","push","source","isPlainObject","const","iface","create","props","rawObject","getOwnPropertyNames","filter","reduce","carry","raw","prop","indexOf","Error","currentValue","get","set","newValue","configurable","keys","init","ObservableObject","$raw","accessProp","Reflect","object","data","ref","watchers","isCurrentlyTrackingPropAccess","currentlyTrackedProp","trackedAccessCache","propDependencyCache","computedPropCache","outdatedComputedPropCache","reactive","allProps","computedProps","invalidateCache","verbose","console","log","hasOwnProperty","assignStaticProp","oldValue","forEach","watcher","assignComputedProp","computedPropDependencies","hasOutdatedValue","wasAlreadyTracking","previouslyTrackedProp","dependencies","reevaluateComputedProp","newDependencies","includeComputed","listener","splice"],"mappings":"SAYgBA,EAAcC,YACjBC,MAAMC,QAAQF,KAA4B,iBAAVA,GAAgC,OAAVA,GAAmBA,EAAMG,aAAeH,EAAMI,UAMjH,SAAgBC,8DACS,IAAnBC,EAAQC,OAAc,MAAM,IAAIC,UAAU,iDAG1C,WAAYC,OAAQ,OAAOA,OAAOC,aAAOD,OAAGH,MAEzB,IAAnBA,EAAQC,OAAc,OAAOD,EAAQ,OAEpCK,IAAIC,KAAON,EAAQ,GACtBA,EAAQ,GAAGM,GAAON,EAAQ,GAAGM,UAGxBP,gBAAOC,EAAQ,WAAOA,EAAQO,MAAM,cC3B7BC,EAAUC,EAAUf,MAC9BD,EAAaC,UACRA,EACF,GAAIC,MAAMC,QAAQF,GAAQ,SACzBgB,EAAOhB,EAAMa,MAAM,GAEhBI,EAAI,EAAGA,EAAID,EAAKT,OAAQU,IAC/BD,EAAKC,GAAKH,EAASC,EAAUC,EAAKC,oBCNCF,qEACnCG,GAAS,EACPC,EAAQ,GACRC,aACCF,GAAQH,KAETM,WAAeC,UAAQR,EAASC,EAAUO,IAG1CC,WAAKC,4EAAoBvB,MAAME,UAAUqB,IAAQC,cAAKN,UAAUO,YAEtEjB,OAAOkB,eAAeR,EAAO,OAAQ,CACnCnB,MAAO,sEACC4B,EAASL,gBAAE,eAAWM,EAASC,IAAIT,YACrCQ,EAAStB,QAAQa,IACdQ,GAETG,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,MAAO,CAClCnB,MAAO,eACCgC,EAAWb,EAAMZ,OACjBqB,EAASL,EAAE,cACbS,GAAUZ,IACPQ,GAETG,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,QAAS,CACpCnB,MAAO,eACCgC,EAAWb,EAAMZ,OACjBqB,EAASL,EAAE,gBACbS,GAAUZ,IACPQ,GAETG,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,UAAW,CACtCnB,MAAO,sEACC4B,EAASL,gBAAE,kBAAcM,EAASC,IAAIT,YACxCQ,EAAStB,QAAQa,IACdQ,GAETG,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,SAAU,CACrCnB,MAAO,SAAiBiC,EAAOC,qEACvBN,EAASL,gBAAE,SAAUU,EAAOC,UAAgBL,EAASC,IAAIT,YAC3DO,EAAOrB,QAAUsB,EAAStB,SAAQa,IAC/BQ,GAETG,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,OAAQ,CACnCnB,MAAO,SAAemC,OACdP,EAASL,EAAE,OAAQY,UACzBf,IACOQ,GAETG,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,UAAW,CACtCnB,MAAO,eACC4B,EAASL,EAAE,kBACjBH,IACOQ,GAETG,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,OAAQ,CACnCnB,wBACSmB,EAAMN,MAAM,IAErBkB,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,OAAQ,CACnCnB,MAAO,SAAeoC,EAAOpC,GAC3BmB,EAAMiB,GAASf,EAAarB,GAC5BoB,KAEFW,YAAY,IAGdtB,OAAOkB,eAAeR,EAAO,WAAY,CACvCnB,MAAO,kBACLkB,GAAS,EACFC,EAAMW,IAAIO,IAEnBN,YAAY,IAIdZ,EAAMmB,WAAKnB,EAAGoB,GAGdrB,GAAS,EAEFC,iBDhG8BJ,UAAaC,IAG3C,YDZsBhB,SACL,iBAAVA,GAAgC,OAAVA,GAAqC,MAAnBA,EAAMG,UCWjDqC,CAAcxC,GAAQ,KACzBgB,EAAOX,EAAO,GAAIL,OAEnByC,IAAM7B,KAAOI,EAChBA,EAAKJ,GAAOE,EAASC,EAAUC,EAAKJ,oBEfAG,EAAUwB,OAC5CG,EAAQjC,OAAOkC,OAAO,MAExBzB,GAAS,EAEP0B,EAAQ,GAERxB,aACCF,GAAQH,cASN8B,WACApC,OAAOqC,oBAAoBJ,GAC/BK,gBAAOnC,SAAkB,MAAXA,EAAI,KAClBoC,gBAAQC,EAAOrC,gBACdP,EAAOI,OAAOkC,OAAO,MAAOM,MAAO,IAAGrC,GAAMsC,EAAIR,EAAM9B,SACtDH,OAAOkC,OAAO,gBAGXhB,EAAgBwB,EAAMnD,OACA,IAAzB4C,EAAMQ,QAAQD,SACV,IAAIE,kBAAkBF,6BAG1BG,EAAetD,EACnBS,OAAOkB,eAAee,EAAOS,EAAM,CACjCI,sBACSD,GAETE,aAAKC,OACGzB,EAAWyB,IAAaH,EAC9BA,EAAexC,EAASC,EAAU0C,GAC9BzB,GAAUZ,KAEhBW,YAAY,EACZ2B,cAAc,IAGhBd,EAAMN,KAAKa,GAEX/B,WAGFX,OAAOkB,eAAee,EAAO,OAAQ,CACnC1C,eAAOmD,EAAMnD,GACX2B,EAAewB,EAAMnD,IAEvB+B,YAAY,IAGdtB,OAAOkB,eAAee,EAAO,OAAQ,CACnC1C,wBACS6C,KAETd,YAAY,IAGdtB,OAAOkB,eAAee,EAAO,WAAY,CACvC1C,wBACEkB,GAAS,EACF2B,KAETd,YAAY,mBAxDP,UAAatB,OAAOkD,KAAKpB,mBAAS,CAAlCE,IAAM7B,OACTe,EAAef,EAAK2B,EAAO3B,KA0D/BgD,GAEA1C,GAAS,EAEFwB,EFzDcmB,CAAiB9C,EAAUC,UAIvChB,WAIKkD,EAAKlD,UACZD,EAAaC,GAASA,EAAM8D,OAAS9D,WAG9BqC,EAAYrC,UACnBD,EAAaC,GAASA,EAAMI,WAAaJ,EG/BlDyC,IAAMsB,EAAaC,QACfA,QAAQT,aACNU,EAAad,UAAiBc,EAAOd,mBAsC3C,SAAmBe,EAAsDC,kBAAsB,oCAAV,OAC7EC,EAAW3D,OAAOkC,OAAO,MAG3B0B,GAAgC,EAChCC,EAAuB,KACvBC,EAAqB9D,OAAOkC,OAAO,MAGjC6B,EAAsB/D,OAAOkC,OAAO,MAGpC8B,EAAoB,GACpBC,EAA4B,GAG5BC,EAAWlE,OAAOkC,OAAO,MAGzBiC,EAAWnE,OAAOkD,KAAKO,GACvBW,EAAgB,YAuEbC,EAAiB3B,GACpB4B,GAASC,QAAQC,IAAI,iCAAkC9B,GAEvDsB,EAAkBS,eAAe/B,KAEnCuB,EAA0BvB,GAAQsB,EAAkBtB,UAC7CsB,EAAkBtB,IAIvBiB,EAASjB,IACXY,EAAWY,EAAUxB,OAIlB,UAAmB1C,OAAOkD,KAAKa,EAAoBrB,oBAAQ2B,iBAQzDK,EAAkBhC,GACrB4B,GAASC,QAAQC,IAAI,yBAA0B9B,OAE/CG,EAAexC,oBAAegE,EAAgB3B,IAAOe,EAAKf,IAE9D1C,OAAOkB,eAAegD,EAAUxB,EAAM,CACpCI,sBACMwB,GAASC,QAAQC,IAAI,oBAAqB9B,EAAM,IAAKG,GAErDe,IACEU,GAASC,QAAQC,IAAI,0CAA2CX,GAEpEC,EAAmBD,GAAsBnB,IAAQ,GAE5CG,GAGTE,aAAKxD,MACCA,IAAUsD,OAER8B,EAAW9B,EACjBA,EAAexC,oBAAegE,EAAgB3B,IAAOnD,GAGjD+E,GAASC,QAAQC,IAAI,wBAAyB9B,EAAM,IAAKG,GACzDyB,GAASC,QAAQC,IAAI,4BAA6BxE,OAAOkD,KAAKa,EAAoBrB,SAEjF,UAAoB1C,OAAOkD,KAAKa,EAAoBrB,oBACvD2B,QAIEV,EAASjB,IAAOiB,EAASjB,GAAMkC,iBAAQC,UAAWA,EAAQhC,EAAc8B,kBAwCzEG,EAAoBpC,GACvB4B,GAASC,QAAQC,IAAI,2BAA4B9B,OAEjDqC,EAA2B,GAC/B/E,OAAOkB,eAAegD,EAAUxB,EAAM,CACpCI,kBACMwB,GAASC,QAAQC,IAAI,6BAA8B9B,GAGnDkB,IACEU,GAASC,QAAQC,IAAI,0CAA2CX,GACpEC,EAAmBD,GAAsBnB,IAAQ,GAI/CsB,EAAkBS,eAAe/B,UAC/B4B,GAASC,QAAQC,IAAI,uBAClBR,EAAkBtB,OAIrBsC,EAAmBf,EAA0BQ,eAAe/B,GAC9D4B,GACFC,QAAQC,IAAIQ,EACR,gCACA,8CAIA7D,WA3DqBuB,OAEzBuC,EAAqBrB,EACrBsB,EAAwBrB,EAG9BD,GAAgC,EAChCC,EAAuBnB,EAGvBoB,EAAmBpB,GAAQ1C,OAAOkC,OAAO,UACnC3C,EAASkE,EAAKf,GAAuB1B,KAAKkD,EAAUA,GACpDiB,EAAenF,OAAOkD,KAAKY,EAAmBpB,IAAS1C,OAAOkC,OAAO,qBACpE4B,EAAmBpB,GAGrBuC,EAGHpB,EAAuBqB,EAFvBtB,GAAgC,EAK3B,cAAEuB,QAAc5F,GAqCJ6F,CAAuB1C,GAEhC2C,EAAkBlE,EAAOgE,mBACPJ,yBAIfhB,QAAwCrB,OAI5C,UAAuB2C,kBAC1BtB,QAAmCrB,IAAQ,SAG7CqC,EAA2B5D,EAAOgE,aAE9Bb,GAASC,QAAQC,IAAI,wCACrBF,GAASC,QAAQC,IAAI,oBAAqBO,GAC1CT,GAASC,QAAQC,IAAI,iBAAkBrD,EAAO5B,OAGlDyE,EAAkBtB,GAAQvB,EAAO5B,MAG7ByF,GAAoBf,EAA0BvB,KAAUvB,EAAO5B,OAASoE,EAASjB,IACnFiB,EAASjB,GAAMkC,iBAAQC,UAAWA,EAAQ1D,EAAO5B,MAAO0E,EAA0BvB,MAIhFsC,UACKf,EAA0BvB,GAG5BvB,EAAO5B,+BA9Nb,UAAc4E,kBAAU,CAAxBnC,IAAMU,OACTqB,EAAoBrB,GAAQ1C,OAAOkC,OAAO,MAGhB,mBAAfuB,EAAKf,IACdoC,EAAmBpC,GACnB0B,EAAcvC,KAAKa,IAInBgC,EAAiBhC,UAkBrB1C,OAAOkB,eAAegD,EAAU,OAAQ,CACtC3E,eAAO+F,0BAAkB,YAVPA,UACXtF,OAAOqC,oBAAoB6B,GAC/B5B,gBAAOnC,SAAkB,MAAXA,EAAI,KAAemF,IAAmD,IAAhClB,EAAczB,QAAQxC,MAC1EoC,gBAAQC,EAAOrC,gBACdP,EAAOI,OAAOkC,OAAO,MAAOM,MAAO,IAAGrC,GAAMsC,EAAIyB,EAAS/D,SACzDH,OAAOkC,OAAO,OAMTE,CAAUkD,IAEnBhE,YAAY,IAIdtB,OAAOkB,eAAegD,EAAU,SAAU,CACxC3E,eAAOmD,EAAM6C,UACL7C,KAAQiB,IACZA,EAASjB,GAAQ,GACjBY,EAAWY,EAAUxB,IAGvBiB,EAASjB,GAAMb,KAAK0D,cAGlB5B,EAASjB,GAAM8C,OAAO7B,EAASjB,GAAMC,QAAQ4C,GAAW,GAEnD5B,EAASjB,GAAM5C,eACX6D,EAASjB,KAItBpB,YAAY,IAGP4C,EA2KFf"}